
	>>>> V E R S I O N    2  <<<<

INTRODUCTION:
Rh was written by Ken Stauffer to make the
job of finding files easier by allowing the
user to enter real C expressions. This notation is
much easier to master than the notation used by the
find(1) command, because most Unix users
already know C. In addition to being easier to use
than find(1), rh expressions can be used to select
the desired files.

CREDITS:
    Ken Stauffer
	- Original author.
    Guy Harris 
	- Corrected many portability problems.
    David MacKenzie 
	- Manual revisions. Added getopt and glob matching.
    Norm Hutchinson
	- Fixed ungetit().
    raf
	- Restored from oblivion after 32 years in the wilderness.
	- Updated to use ANSI/ISO C and POSIX.
	- Fixed buffer overflow security bugs and usability problems.

INSTALLING:
To install rh on your system:

    make
    make install

RUNNING:
There is a file called rhrc. This file contains some
examples of things that can go into a $HOME/.rhrc file.
If the file "rhrc" is moved to your home directory and renamed
to ".rhrc" then a command like:

	% rh -l -e writable

Will do a search of the current directory, executing the function
"writable()", which finds files that other people have write access to.

Once rh is made, you can do what you want with it. A good test to
see if it is working is to do:

	% rh -vle 1 /

This will find all files that make the constant expression '1' true.
So if you're root, all the files on the system will be found.

PORTABILITY:
Rh is written in ANSI/ISO C and should work on any POSIX system.

EXAMPLES:
Here are some example functions that can be defined in your ~/.rhrc file:

	dir() { return (mode & IFMT) == IFDIR; }
	months { return days * 30; }
	nlinks { return nlink; }
	writable() { return mode & 022; }
	mine { return uid == $$; }
	freds { return uid == $fred; }
	csrc() { return "*.c" || "*.h" || "[Mm]akefile"; }
	ago(d) { return NOW - d; }
	changed() { return mtime > ago(1 * hours); }
	K() { return 1024; }
	megs { return K << 10; }
	recursion(n) { return (n > 0) ? recursion(n - 1) + 1 : 0; }

GRAMMER:
The following is the grammer that describes the input language
recognized by rh:

	<program> ==> <function list> <expression> EOF
		| <function list> <expression> ;

	<function list> ==> <function>
		| <function list> <function>
		| /* empty */

	<function> ==> <function heading> { RETURN <expression> ; }

	<function heading> ==> IDENTIFIER
		| IDENTIFIER ( )
		| IDENTIFIER ( <idlist> )

	<idlist> ==> IDENTIFIER <idtail>
	<idtail> ==> , <idlist>
		| /* empty */
	
	<expression> ==> <expr0> ? <expression> : <expression>

	<expr0> ==> <expr1> || <expr1>

	<expr1> ==> <expr2> && <expr2>

	<expr2> ==> <expr3> | <expr3>

	<expr3> ==> <expr4> ^ <expr4>

	<expr4> ==> <expr5> & <expr5>

	<expr5> ==> <expr6> == <expr6>
		|   <expr6> != <expr6>

	<expr6> ==> <expr7> < <expr7>
		|   <expr7> > <expr7>
		|   <expr7> <= <expr7>
		|   <expr7> >= <expr7>

	<expr7> ==> <expr8> >> <expr8>
		|   <expr8> << <expr8>

	<expr8> ==> <expr9> + <expr9>
		|   <expr9> - <expr9>

	<expr9> ==> <expr10> * <expr10>
		|   <expr10> / <expr10>
		|   <expr10> % <expr10>

	<expr10> ==> ~ <expr10>
		|    ! <expr10>
		|    - <expr10>
		|    <factor>

	<factor> ==> ( <expression> )
		|    NUMBER
		|    <function call>
		|    IDENTIFIER
		|    [ <date spec> ]
		|    STRING

	<function call> ==> IDENTIFIER
		| IDENTIFIER ( <exprlist> )
		| IDENTIFIER ( )

	<exprlist> ==> <expression> <exprtail>
	<exprtail> ==> , <exprlist>
		| /* empty */

	<datespec> ==> NUMBER / NUMBER / NUMBER

--------------------------------------------------------------------
Ken Stauffer.
root@sixk
